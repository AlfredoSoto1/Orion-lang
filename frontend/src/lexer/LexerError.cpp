#include "LexerError.hpp"

namespace compiler {

  std::string_view LexerError::to_string() {
    switch (type) {
      case LexerErrorType::UNKNOWN_ERROR:
        return "Unknown error encountered.";
      case LexerErrorType::UNKNOWN_TOKEN:
        return "Unknown token generated by the lexer.";
      case LexerErrorType::UNEXPECTED_EOF:
        return "Unexpected end of file while lexing.";
      case LexerErrorType::INVALID_CHARACTER:
        return "Invalid or unrecognized character encountered.";

      case LexerErrorType::UNEXPECTED_WHITESPACE:
        return "Unexpected whitespace found in an invalid position.";
      case LexerErrorType::INDENTATION_ERROR:
        return "Incorrect indentation detected.";

      case LexerErrorType::UNCLOSED_STRING_LITERAL:
        return "String literal is missing a closing quote.";
      case LexerErrorType::INVALID_ESCAPE_SEQUENCE:
        return "Invalid escape sequence inside a string literal.";
      case LexerErrorType::UNTERMINATED_RAW_STRING:
        return "Raw string is missing its termination sequence.";

      case LexerErrorType::INVALID_CHAR_LITERAL:
        return "Invalid character literal format.";
      case LexerErrorType::UNCLOSED_CHAR_LITERAL:
        return "Character literal is missing a closing quote.";
      case LexerErrorType::MULTI_CHAR_CHAR_LITERAL:
        return "Character literal contains more than one character.";

      case LexerErrorType::INVALID_FLOAT_LITERAL:
        return "Invalid floating-point number format.";
      case LexerErrorType::INVALID_NUMBER_LITERAL:
        return "Invalid numeric literal format.";
      case LexerErrorType::UNEXPECTED_RADIX_PREFIX:
        return "Unexpected or incorrect use of radix prefix.";
      case LexerErrorType::OVERFLOW_NUMBER_LITERAL:
        return "Numeric literal exceeds the maximum storage capacity.";

      case LexerErrorType::UNCLOSED_BLOCK_COMMENT:
        return "Block comment is missing its closing delimiter.";
      case LexerErrorType::INVALID_NESTED_COMMENT:
        return "Invalid nested comment detected (if not supported).";

      case LexerErrorType::UNKNOWN_PUNCTUATOR:
        return "Unrecognized punctuator or symbol.";
      case LexerErrorType::INVALID_IDENTIFIER_LENGTH:
        return "Identifier exceeds the maximum allowed length (256).";
      case LexerErrorType::INVALID_UTF8_SEQUENCE:
        return "Invalid UTF-8 sequence encountered.";
    }
    return "Unspecified lexer error.";  // Fallback case (should never happen)
  }
}  // namespace compiler
